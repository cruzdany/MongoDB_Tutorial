####CHEAT SHEET MONGODB BY DANIEL CRUZ###

use database 

#The command “use” automatically creates you a database and puts you inside of it with the name “database”

var new = {
	     “name”: “Daniel”, 
             “lastname”: “Cruz”
	  } 

#This crates you a variable called new, which have your name and your last name

new 

#This show you your variable and what is inside of it

db.new1.insert ({
		   “name”: Daniel, 
	           “lastname”: “Cruz”
		}) 

#This creates you a new database called new1 and with this command you insert the data inside of it

#This should show you this “WriteResult({ "nInserted": 1 }”

#Each new data you insert has a unique Object ID, which is generated by default by the system

#If you for example want to find the whole database you has already created, you can use this:

db.new1.find() 

#If you want to find a specific database, you have to punt inf the searcher, something like this: 

db.new1.find({
		“name”: “Daniel”
	    }) 

#This will show you the specific new1, which has the exactly data you put in order to find.

#If you for example, want to find documents which has the type "Sad_music" and will match with all of them, like this:
db.potions.find({"vendor": "Sad_music"})
{     
   "_id": ObjectId("55d232a5819aa726..."),
   "name":"Reik", 
   "type":"Sad_music" }  
{  "_id": ObjectId("55c3b9501aad0cb0..."),
   "name":"Juan Gabriel", 
   "type":"Sad_music"}

#If your for example want to save inside the database a object, you could use this:

db.new1.insert ({
		    “Ingredients”: {“strength”: 2, “flavot”: 5}) 

#As you could see, you not only can store strings you can also add Numbers: 2, 3.456; Boolenas: True, False; Arrays: #[
#new array]; Null values; the date, but in this case, the months start in 0, so, if for example, you, want to use the month March, 
#you should put something like this: new Date(2012, 2, 8), and this will show you the March 8th of 2012.

#Delete a single document

#The remove() collection method will delete documents that match the provided query

db.music.remove(
	{"name": "Reik"}
)

#You should see as a result, something like this:

#WriteResult({ "nRemoved": 1 }

#In this way the document has beed removed


#Delete multiple Documents

#If your query matches multiply documents, the remove() will delete all of them

db.music.remove(
	{"type": "Sad_music"}
)
WritteResult({ "nRemoved": 2})

#In this way, it removed both documents that matches with the vendor

#UPDATING

#You must use the "$set" if you only write "set" that will be your new parameter
#When multi is true, the update modifies all matching documents

	db.music.update({"name": "Reik"},
		{"$set": {"name": "Justin Bieber"})


#Update Without an Operator

#First, we insert a data:

db.music.insert({"name": Justin Bieber, "type": pop, "year": 2005})

db.music.update({"name": Justin Bieber, "type": "pop", "year": 2008})

#So, here our document will be updated


#Updating Multiple Documents

#The update method can take a third parameter for options

db.music.update(  
		{"type": "Cumbias"}, {"$set": {"type": "Sad_music"}}, {"multi": true}
		)

#You should see this:

WriteResult({
	"nMatched": 3,
	"Upserted": 0,
	"nModified": 3
})		

#Update a Document’s Count


#We can use the $incoperator to increment the count of an existing log document.

db.music.update({"name": "Justin Bieber"}, 
				{"$inc": {"count": 1}}
			    )
#With $inc, the value will be incrementing


#Update a Non-existing Potion

db.music.update({"name": "The Weekend"}, {"$inc": {"count": 1}}
				)

#This is what should show up:

WriteResult({               
			"nMatched": 0,       
			"nUpserted": 0,       
			"nModified": 0}
			)		


#Find or Create With Upsert	

#The upsert option either updates an existing document or creates a new one.

#If the data does not exist, it creates a new one

db.music.update({"name": "Justin Bieber"}, {"$inc": {"count": 1}}, {"upsert": true}
				)

#You should see this:

WriteResult({               
			"nMatched": 0,       
			"nUpserted": 1,  #Here it is the modification  A document created
			"nModified": 0})


#Updating Once More
#If we run the same update again, the update will act normally and upsert won’t create another document

db.music.update({"name": "Justin Bieber"}, {"$inc": {"count": 1}}, {"upsert": true}
				)

#This will probably show up:

WriteResult({              
			"nMatched": 1,       
 			"nUpserted": 0,       
 			"nModified": 1}
 			)

#The document is found and modified but nothing is created


#Removing Fields From Documents
db.music.update({},
				{"$unset": {"type": ""}},{"multi": true}
				)

#The {} in black is referring for all music
#The multi update all potions				
#The "" will delete all the type of all music


#Updating a Field Name With $rename

#We can use $rename to change field names

db.music.update({}, {"$rename": {"type": "kind_of_music"}}, {"multi": true}
				)

#When using $rename we are specifing a field
#"type" will be the old name and "kind_of_music" will be the new name of that field


#Potion Ingredient Regulation

#This allows us to update an array, but in order of doing this, we have to add first an array in our current database:

db.music.insert({"name": "Anuel aa", "best_sellers": ["Bebe", "Amanecer", "Verte ir"]}
				)
#Let's asume we want to change "Verte ir" with the number 21

#This is what will do:

db.music.update({"best_sellers": "Verte ir"}, {"$set": {"best_sellers": "23"}}
				)

#As you could see, this changed the entire array with only one value, which is 23, instead of updating only one element

#So, what we can do in order of solving this is:


#Updating Array Values by Location
#pos = position

#{"best_sellers": ["Bebe", "Amanecer", "Verte ir"]}
				   pos0      pos1        pos2

#Updating Single Array Value
#The $set operator will update the value or a specific field

db.music.update({"name": "Justin Bieber"}, {"$set": "best_sellers.2": 23})

#This will show up:

WriteResult({"nMatched": 1,"nUpserted": 0,"nModified: 1})

#And this will be like this now

#({"name": "Anuel aa", "best_sellers": ["Bebe", "Amanecer", "23"]})


#Updating Multiple Arrays
#If we want to update multiple arrays, what we would use is the "$" in the specific field by adding it with a point, like this: "best_sellers.$"

db.music.update(
				{"best_sellers": "Verte ir"}, {"$set": {"best_sellers.$": 23 }}, {"multi": true}
			   )
#Assuming you inserted more documents with different best sellers, it will show up, something like this:

#["Adictiva", 23, "A solas"]
#["23, "Secreto", "Quiere Beber"]
#["Culpables", "Ella Quiere Beber Remix", 23]			   


#Removing the First or Last Value of an Array
#If you put the 1, it will remove the first element and if you put -1, it will remove the last element
#The $popoperator will remove either the first or last value of an array

db.music.update({"name": "Anuel Aa"}, {"$pop": {"best_sellers": 1}})


#Adding Values to the End of an Array
#The $push operator will add a value to the end of an array.

db.music.update({"name": "Anuel Aa"}, {"$push": {"best_sellers": "Te Boté"}})

#It will be added to the end


#Adding Unique Values to an Array
#The $addToSet operator will add a value to the end of an array unless it is already present

db.music.update({"name": "Anuel Aa"}, {"$addToSet": {"best_sellers": "Te Boté"}})

#Since it is already added, it won´t be added again


#Removing Values From an Array
#The $pull operator will remove any instance of a value from an array

db.music.update({"name": "Anuel Aa"}, {"$pull": {"best_sellers": "Te Boté"}})

#It will be removed from the array


#Querying With Multiple Criteria




#Aggregate method

#“Aggregate” is a fancy word for combining data

#Before doing this, of course you must have data inserted in that database, but those data will be combined with these ones others.
#For example

db.music.insert(
	{"name": "Reik", "type": "Pop"}
	)

#And this one will be combined

db.music.aggregate(
	[{"$group": {"_id": "type"}}]
)


#Using the Aggregation Framework to Group Data

#For doing this, we will insert four more music data
db.music.insert(
	{"name": "Buki", "type": "Sad_music"}
	)

db.music.insert(
	{"name": "Bad Bunny", "type": "Reggaeton"}
	)

db.music.insert(
	{"name": "Juan Gabriel", "type": "Sad_music"}
	)

#Now we pass to the aggregate method
s
db.music.aggregate(
	[{"$group": {"_id": "$type"}}]
)

#What you should see, is this:

{"_id": "Sad_music"},
{"_id": "Reggaeton"},
{"_id": "Sad_music"}

#In the "_id", you will see the "type" of music


#Using Accumulators

db.music.aggregate([{
	"$group": {"_id": "$type", "total": {"$sum": 1}}
}])

#What you should see is the sum of how many have the same type of music in the "_id" field

{"_id": "Sad_music", "total": 2},
{"_id": "Reggaeton", "total": 1}

#Field Paths Vs. Operators

#When values begin with a "$", they represent field paths that point to the value

#When fields begin with a "$", they are operators that perform a task

#Example 

#db.music.aggregate([{
#	"$group": {"_id": "$type", "total": {"$sum": 1}}
#}])

#They are the "$group" and "$type"

#Summing the Grade Per type	

#The "$grade" is the field path

db.potions.aggregate(
	[{"$group": {"id": "$type", "total": {"$sum": 1}, "grade_total": {"$sum": "$grade"}}}
	])
	
#Then you will see something like this

{ "_id" : "Pop", "total" : 1, "grade_total" : 0 }
{ "_id" : "Reggaeton", "total" : 1, "grade_total" : 0 }
{ "_id" : "Sad_music", "total" : 2, "grade_total" : 0 }


#Averaging Potion Grade Per type

db.music.aggregate(
	[{"$group": {"_id": "$type", "avg_type": {"$avg": "$type"}}}]
	)

#You should see somehting like this:


{ "_id" : "Pop", "avg_type" : null }
{ "_id" : "Reggaeton", "avg_type" : null }
{ "_id" : "Sad_music", "avg_type" : null }


#Using $max and $min Together
#Here, we should take in consideration the reserved words, which are "$max" and "$min", and what this ones will show you is the minimum and maximum value

db.music.aggregate(
	[{"$group": {"_id": "$type", "max_grade": {"$max": "$type"}, "min_grade": {"$min": "$grade"}}}]
	)

#We should see something like this: 

{ "_id" : "Pop", "max_grade" : "Pop", "min_grade" : null }
{ "_id" : "Reggaeton", "max_grade" : "Reggaeton", "min_grade" : null }
{ "_id" : "Sad_music", "max_grade" : "Sad_music", "min_grade" : null }


#####QUESTIONS#######

#1. What is MongoDB?
Mongo-DB is a document database which provides high performance, high availability and easy scalability. 

#2. What are indexes in MongoDB?
Indexes are special structures in MongoDB, which stores a small portion of the data set in an easy to traverse form. 
Ordered by the value of the field specified in the index, the index stores the value of a specific field or set of fields. 

#3. What makes MongoDB the best?
MongoDB is considered to be best NoSQL database because of :Document-oriented (DO)
High performance (HP)
High availability (HA)
Easy scalability
Rich query language

#4. What is “Namespace” in MongoDB?
The concatenation of the collection name and database name is called a namespace.  
MongoDB stores BSON (Binary Interchange and Structure Object Notation) objects in the collection. 

#5. How is MongoDB better than other SQL databases?
MongoDB allows a highly flexible and scalable document structure. 
For example, one data document in MongoDB can have five columns and the other one in the same collection can have ten columns. 
Also, MongoDB database are faster as compared to SQL databases due to efficient indexing and storage techniques.

#6. What is the role of profiler in MongoDB?
MongoDB database profiler shows performance characteristics of each operation against the database. 
You can find queries using the profiler that are slower than they should be. 

#7. What is the feature in MongoDB to do safe backups that you can use?
Journaling is the feature in MongoDB that you can use to do safe backups. 

#8. What is CRUD in MongoDB?
Mongodb provides CRUD operations that are create, Read, Update, Delete.

#9. What is sharding?
Sharding means to store the data on the multiple machines.

#10. What is replication?
Replication is the process of synchronizing data across multiple servers.

#11. What is use of GridFS in mongodb?
GridFS is used for storing and retrieving the large files like audio, Images, Video files.

#12. Which type of data mongodb store?
MongoDB stores data in the form of documents, which are JSON-like field and value pairs.

#13. What is storage encryption?
Storage Encryption encrypts all MongoDB data on the storage or operating system to ensure that only authorized processes can access protected data.

#14. What is Map reduce?
Map-reduce is a generic multi-phase data aggregation modality which is used for processing quantities of data.

#15. What is a covered query in MongoDB?
A covered query is the one in which:
Fields used in the query are part of an index used in the query, and
The fields returned in the results are in the same index


#READ THE BOOK UNTIL PAGE 54