####LEARN MONGODB IN Y MINUTES######

####CHEAT SHEET MONGODB BY DANIEL CRUZ###

use database 

#The command “use” automatically creates you a database and puts you inside of it with the name “database”

var new = {
	     “name”: “Daniel”, 
             “lastname”: “Cruz”
	  } 

#This crates you a variable called new, which have your name and your last name

new 

#This show you your variable and what is inside of it

db.new1.insert ({
		   “name”: Daniel, 
	           “lastname”: “Cruz”
		}) 

#This creates you a new database called new1 and with this command you insert the data inside of it

#This should show you this “WriteResult({ "nInserted": 1 }”

#Each new data you insert has a unique Object ID, which is generated by default by the system

#If you for example want to find the whole database you has already created, you can use this:

db.new1.find() 

#If you want to find a specific database, you have to punt inf the searcher, something like this: 

db.new1.find({
		“name”: “Daniel”
	    }) 

#This will show you the specific new1, which has the exactly data you put in order to find.

#If you for example, want to find documents which has the type "Sad_music" and will match with all of them, like this:
db.potions.find({"vendor": "Sad_music"})
{     
   "_id": ObjectId("55d232a5819aa726..."),
   "name":"Reik", 
   "type":"Sad_music" }  
{  "_id": ObjectId("55c3b9501aad0cb0..."),
   "name":"Juan Gabriel", 
   "type":"Sad_music"}

#If your for example want to save inside the database a object, you could use this:

db.new1.insert ({
		    “Ingredients”: {“strength”: 2, “flavot”: 5}) 

#As you could see, you not only can store strings you can also add Numbers: 2, 3.456; Boolenas: True, False; Arrays: #[
#new array]; Null values; the date, but in this case, the months start in 0, so, if for example, you, want to use the month March, 
#you should put something like this: new Date(2012, 2, 8), and this will show you the March 8th of 2012.

#Delete a single document

#The remove() collection method will delete documents that match the provided query

db.music.remove(
	{"name": "Reik"}
)

#You should see as a result, something like this:

#WriteResult({ "nRemoved": 1 }

#In this way the document has beed removed


#Delete multiple Documents

#If your query matches multiply documents, the remove() will delete all of them

db.music.remove(
	{"type": "Sad_music"}
)
WritteResult({ "nRemoved": 2})

#In this way, it removed both documents that matches with the vendor

#UPDATING

#You must use the "$set" if you only write "set" that will be your new parameter
#When multi is true, the update modifies all matching documents

	db.music.update({"name": "Reik"},
		{"$set": {"name": "Justin Bieber"})


#Update Without an Operator

#First, we insert a data:

db.music.insert({"name": Justin Bieber, "type": pop, "year": 2005})

db.music.update({"name": Justin Bieber, "type": "pop", "year": 2008})

#So, here our document will be updated


#Updating Multiple Documents

#The update method can take a third parameter for options

db.music.update(  
		{"type": "Cumbias"}, {"$set": {"type": "Sad_music"}}, {"multi": true}
		)

#You should see this:

WriteResult({
	"nMatched": 3,
	"Upserted": 0,
	"nModified": 3
})		

#Update a Document’s Count


#We can use the $incoperator to increment the count of an existing log document.

db.music.update({"name": "Justin Bieber"}, 
				{"$inc": {"count": 1}}
			    )
#With $inc, the value will be incrementing


#Update a Non-existing Potion

db.music.update({"name": "The Weekend"}, {"$inc": {"count": 1}}
				)

#This is what should show up:

WriteResult({               
			"nMatched": 0,       
			"nUpserted": 0,       
			"nModified": 0}
			)		


#Find or Create With Upsert	

#The upsert option either updates an existing document or creates a new one.

#If the data does not exist, it creates a new one

db.music.update({"name": "Justin Bieber"}, {"$inc": {"count": 1}}, {"upsert": true}
				)

#You should see this:

WriteResult({               
			"nMatched": 0,       
			"nUpserted": 1,  #Here it is the modification  A document created
			"nModified": 0})


#Updating Once More
#If we run the same update again, the update will act normally and upsert won’t create another document

db.music.update({"name": "Justin Bieber"}, {"$inc": {"count": 1}}, {"upsert": true}
				)

#This will probably show up:

WriteResult({              
			"nMatched": 1,       
 			"nUpserted": 0,       
 			"nModified": 1}
 			)

#The document is found and modified but nothing is created


#Removing Fields From Documents
db.music.update({},
				{"$unset": {"type": ""}},{"multi": true}
				)

#The {} in black is referring for all music
#The multi update all potions				
#The "" will delete all the type of all music


#Updating a Field Name With $rename

#We can use $rename to change field names

db.music.update({}, {"$rename": {"type": "kind_of_music"}}, {"multi": true}
				)

#When using $rename we are specifing a field
#"type" will be the old name and "kind_of_music" will be the new name of that field


#Potion Ingredient Regulation

#This allows us to update an array, but in order of doing this, we have to add first an array in our current database:

db.music.insert({"name": "Anuel aa", "best_sellers": ["Bebe", "Amanecer", "Verte ir"]}
				)
#Let's asume we want to change "Verte ir" with the number 21

#This is what will do:

db.music.update({"best_sellers": "Verte ir"}, {"$set": {"best_sellers": "23"}}
				)

#As you could see, this changed the entire array with only one value, which is 23, instead of updating only one element

#So, what we can do in order of solving this is:


#Updating Array Values by Location
#pos = position

#{"best_sellers": ["Bebe", "Amanecer", "Verte ir"]}
				   pos0      pos1        pos2

#Updating Single Array Value
#The $set operator will update the value or a specific field

db.music.update({"name": "Justin Bieber"}, {"$set": "best_sellers.2": 23})

#This will show up:

WriteResult({"nMatched": 1,"nUpserted": 0,"nModified: 1})

#And this will be like this now

#({"name": "Anuel aa", "best_sellers": ["Bebe", "Amanecer", "23"]})


#Updating Multiple Arrays
#If we want to update multiple arrays, what we would use is the "$" in the specific field by adding it with a point, like this: "best_sellers.$"

db.music.update(
				{"best_sellers": "Verte ir"}, {"$set": {"best_sellers.$": 23 }}, {"multi": true}
			   )
#Assuming you inserted more documents with different best sellers, it will show up, something like this:

#["Adictiva", 23, "A solas"]
#["23, "Secreto", "Quiere Beber"]
#["Culpables", "Ella Quiere Beber Remix", 23]			   


#Removing the First or Last Value of an Array
#If you put the 1, it will remove the first element and if you put -1, it will remove the last element
#The $popoperator will remove either the first or last value of an array

db.music.update({"name": "Anuel Aa"}, {"$pop": {"best_sellers": 1}})


#Adding Values to the End of an Array
#The $push operator will add a value to the end of an array.

db.music.update({"name": "Anuel Aa"}, {"$push": {"best_sellers": "Te Boté"}})

#It will be added to the end


#Adding Unique Values to an Array
#The $addToSet operator will add a value to the end of an array unless it is already present

db.music.update({"name": "Anuel Aa"}, {"$addToSet": {"best_sellers": "Te Boté"}})

#Since it is already added, it won´t be added again


#Removing Values From an Array
#The $pull operator will remove any instance of a value from an array

db.music.update({"name": "Anuel Aa"}, {"$pull": {"best_sellers": "Te Boté"}})

#It will be removed from the array


#Comparison Query Operators
#There are comon comparison query operators to match documents given a specific value we can use:

$gt #greater than
$lt #less than
$gte #greater or equal to
$lte #less or equal to
$ne #not equal to

#Finding Potions That Are Less Than "any value"
#First: insert two examples
db.music.insert({"name": "Drake", "year": 2005})
db.music.insert({"name": "Kendrick Lamar", "year": 2004})
#Now we make the query
db.music.find({"year": {"$lt: 2005}})

#Finding Potions Between Prices
db.music.find({"year": {"$gt": 2003, "$lt": 2006}})

#Queries of Non-equality
db.music.find({"year": {"$ne": 2005}})


#Projections 
#You can use $find to use the projections, we can use it to specify the exact fields we want to find by setting their value to true
db.music.find({"year": {"$gte": 2002}}, {"name": true})

#Excluding Fields

db.music.find({"year": {"$gte": 2003}}, {"name": true, "type": false})

#Counting Our Music
#We can count the total of our music by using the method count

db.music.find().count()

#Sorting
#If we ant to sort our document, we can do it by using find() and the method sort()
#We have to take in consideration that 1 is ascending order and -1 is descending order

db.music.find.sort({"name": 1})

db.music.find().sort({"name": -1}) 


#If you want to limit the pages of your document, you could use the limit() and skip() methods

db.music.find().limit(4)
db.music.find().skip(4).limit(4)

#An important thing to take in consideration is that MongoDB allows embedding documents specifying or adding missing data 
#If you have a duplication on the data, you can make a reference on a new collection
#You must use the "id" of the each document to develop a better query and reference the collection you did
#if you have the reference on a document, the collection will have that part of the information that was referenced
#You can't write new parameters in atomic level if the syntax doesn't is from the same collection

#In MongoDB is not allowed the transactions for the relationship between queries and collection.

#Differences between embedding and referecing a document:
Embedding:
#Single query
#Documents accsed through parent
#Atomic writes

Referencing:
#Requires 2 queries
#Documents exist independently
#Doesn't support multi-document writes

#Comments are allowed on both of them

#Aggregation Framework
#Aggregate method

#“Aggregate” is a fancy word for combining data

#Before doing this, of course you must have data inserted in that database, but those data will be combined with these ones others.
#For example

db.music.insert(
	{"name": "Reik", "type": "Pop"}
	)

#And this one will be combined

db.music.aggregate(
	[{"$group": {"_id": "type"}}]
)


#Using the Aggregation Framework to Group Data

#For doing this, we will insert four more music data
db.music.insert(
	{"name": "Buki", "type": "Sad_music"}
	)

db.music.insert(
	{"name": "Bad Bunny", "type": "Reggaeton"}
	)

db.music.insert(
	{"name": "Juan Gabriel", "type": "Sad_music"}
	)

#Now we pass to the aggregate method
s
db.music.aggregate(
	[{"$group": {"_id": "$type"}}]
)

#What you should see, is this:

{"_id": "Sad_music"},
{"_id": "Reggaeton"},
{"_id": "Sad_music"}

#In the "_id", you will see the "type" of music


#Using Accumulators

db.music.aggregate([{
	"$group": {"_id": "$type", "total": {"$sum": 1}}
}])

#What you should see is the sum of how many have the same type of music in the "_id" field

{"_id": "Sad_music", "total": 2},
{"_id": "Reggaeton", "total": 1}

#Field Paths Vs. Operators

#When values begin with a "$", they represent field paths that point to the value

#When fields begin with a "$", they are operators that perform a task

#Example 

#db.music.aggregate([{
#	"$group": {"_id": "$type", "total": {"$sum": 1}}
#}])

#They are the "$group" and "$type"

#Summing the Grade Per type	

#The "$grade" is the field path

db.potions.aggregate(
	[{"$group": {"id": "$type", "total": {"$sum": 1}, "grade_total": {"$sum": "$grade"}}}
	])
	
#Then you will see something like this

{ "_id" : "Pop", "total" : 1, "grade_total" : 0 }
{ "_id" : "Reggaeton", "total" : 1, "grade_total" : 0 }
{ "_id" : "Sad_music", "total" : 2, "grade_total" : 0 }


#Averaging Potion Grade Per type

db.music.aggregate(
	[{"$group": {"_id": "$type", "avg_type": {"$avg": "$type"}}}]
	)

#You should see somehting like this:


{ "_id" : "Pop", "avg_type" : 90 }
{ "_id" : "Reggaeton", "avg_type" : 60 }
{ "_id" : "Sad_music", "avg_type" : 80 }


#Using $max and $min Together
#Here, we should take in consideration the reserved words, which are "$max" and "$min", and what this ones will show you is the minimum and maximum value

db.music.aggregate(
	[{"$group": {"_id": "$type", "max_grade": {"$max": "$type"}, "min_grade": {"$min": "$grade"}}}]
	)

#We should see something like this: 

{ "_id" : "Pop", "max_grade" : "Pop", "min_grade" : 90 }
{ "_id" : "Reggaeton", "max_grade" : "Reggaeton", "min_grade" : 60 }
{ "_id" : "Sad_music", "max_grade" : "Sad_music", "min_grade" : 80 }


#Aggregation Pipeline
#Here we can pass data through many stages in order to change it along the way

db.music.aggregate([stage, stage, stage])

#What a stage look like is like this: 

db.music.aggregate({"$group": {"_id": "$name", "total": {"$sum": 1}}})

#How does it work? Well, each stage modifies the working data set and then passes the altered documents to the next stage until we get our desired result.

#$match operator
#We can use it to reduce the number of documents for better performance

db.muisc.aggregate([{"$match": {"best_sellers": "Bebe"}}])

#Grouping Potions With Data 
#
db.music.aggregate([{"$match": {"best_sellers": "Bebe"}}, {"$group": {"_id": "name", "year_count": {"$sum": 1}
					}
				}]
			)

#We can also Match with the query operators

db.muisc.find([{"$match": {"year": {"$lt": 2007}}}
			])

#We also can make Grouping in match

db.music.aggregate([{"$match": {"year": {"$lt": 2007}}}, {"$group": {"_id": "$name"}}
				  ])

#We can use too limitings in Match

db.music.aggregate([{"$match": {"year": {"$lt": 2007}}}, {"$group": {"_id": "$name"}}, {"$limit":  3}
				  ])

#Projections While Aggregating
#It is common to see $match and $project used together early on and throughout the pipeline

db.muisc.aggregate([{"$match": {"year": {"$lt": 2006}}}, {"$project": {"_id": false, "name_id": true, "year": false}}])			

#####QUESTIONS#######

#1. What is MongoDB?
Mongo-DB is a document database which provides high performance, high availability and easy scalability. 

#2. What are indexes in MongoDB?
Indexes are special structures in MongoDB, which stores a small portion of the data set in an easy to traverse form. 
Ordered by the value of the field specified in the index, the index stores the value of a specific field or set of fields. 

#3. What makes MongoDB the best?
MongoDB is considered to be best NoSQL database because of :Document-oriented (DO)
High performance (HP)
High availability (HA)
Easy scalability
Rich query language

#4. What is “Namespace” in MongoDB?
The concatenation of the collection name and database name is called a namespace.  
MongoDB stores BSON (Binary Interchange and Structure Object Notation) objects in the collection. 

#5. How is MongoDB better than other SQL databases?
MongoDB allows a highly flexible and scalable document structure. 
For example, one data document in MongoDB can have five columns and the other one in the same collection can have ten columns. 
Also, MongoDB database are faster as compared to SQL databases due to efficient indexing and storage techniques.

#6. What is the role of profiler in MongoDB?
MongoDB database profiler shows performance characteristics of each operation against the database. 
You can find queries using the profiler that are slower than they should be. 

#7. What is the feature in MongoDB to do safe backups that you can use?
Journaling is the feature in MongoDB that you can use to do safe backups. 

#8. What is CRUD in MongoDB?
Mongodb provides CRUD operations that are create, Read, Update, Delete.

#9. What is sharding?
Sharding means to store the data on the multiple machines.

#10. What is replication?
Replication is the process of synchronizing data across multiple servers.

#11. What is use of GridFS in mongodb?
GridFS is used for storing and retrieving the large files like audio, Images, Video files.

#12. Which type of data mongodb store?
MongoDB stores data in the form of documents, which are JSON-like field and value pairs.

#13. What is storage encryption?
Storage Encryption encrypts all MongoDB data on the storage or operating system to ensure that only authorized processes can access protected data.

#14. What is Map reduce?
Map-reduce is a generic multi-phase data aggregation modality which is used for processing quantities of data.

#15. What is a covered query in MongoDB?
A covered query is the one in which:
Fields used in the query are part of an index used in the query, and
The fields returned in the results are in the same index

##REFERENCES##
https://www.tutorialspoint.com/mongodb/mongodb_interview_questions.htm
https://intellipaat.com/interview-question/mongodb-interview-questions/
http://www.webdevelopmenthelp.net/2017/01/mongodb-interview-questions.html


#################### EXTRA MATERIAL ##############################################
#################### IMPORTANT QUESTIONS TO TAKE IN CONSIDERATION #####################

###Usage Of MongoDB###
#Where can we use MongoDB?
#We use MongoDB as the primary data store for operational applications with real-time requirements. 
#MongoDB is fit to use for 60%-80% of the applications that are developing in today’s world.

#Does MongoDb require a lot of RAM?
#MondoDB uses the free memory that is on the computer as its cache..

#When should we use MongoDB?
#If you can represent your data in a form of a bunch of documents, MongoBD is the option.

#When should not we use Mongo DB?
#If you would rather imagine your data as a bunch of interconnected tables, MongoDB would not be the right option.

###MongoDB and SQL Database Manager###
#How is MongoDB better than other SQL databases?
#MongoDB allows a highly flexible and scalable document structure. 
#For example, one data document in MongoDB can have five columns and the other one in the same collection can have ten columns. 
#Also, MongoDB database are faster as compared to SQL databases due to efficient indexing and storage techniques.

#Does MongoDB support SQL?
#Not directly, no. However, MongoDB does support a rich query language of its own.

#What are differences between MongoDB and MySQL?
#Both these databases are free and open source.
#The speed in which your queries are being processed in MongoDB is fast 
#as compared to MySQL. The way in which data is being represented in MongoDB and MySQL is also very different.

#It depends on the problem you face, if you have a database with a structure already defined, then MySQL is for you, if your database does #not have an apparent order then MongoDb is what you need. The difference is that currently most data banks are presented without any #specific order so MongoDb is having more presence.

###Basic Commands###
#What is "namespace" in MongoDB?
#MongoDB stores BSON (Binary Interchange and Structure Object Notation) objects in the collection. The concatenation of the collection name #and database name is called a namespace. 

###Collections and Databases###
#What is collection in MongoDB?
#A collection is a group of documents. If a document is the MongoDB analog of a row in a relational database, then collection is 
#the analog to a table. Collections have dynamic schemas. This means that the documents within a single collection can have any 
#number of different shapes. 